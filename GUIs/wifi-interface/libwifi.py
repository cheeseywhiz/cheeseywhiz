import re
from subprocess import PIPE, Popen, STDOUT
from collections.abc import MutableMapping


def akh(*args, **kwargs):
    """
    akh: args/kwargs helper

    Return a two-tuple containing the arguments tuple and the keyword
    dictionary of the called function.
    """
    return args, kwargs


def Ppipe(*args_chain):
    """
    Return the Popen instance of the pipe chain of each command in the list.
    Each argument shall be Popen arguments supplied by akh().
    """
    first, *args_chain = args_chain

    fargs, fkwargs = first
    fkwargs.update({'stdout': PIPE})
    new = Popen(*fargs, **fkwargs)

    for args in args_chain:
        old = new
        fargs, fkwargs = args
        fkwargs.update({'stdin': old.stdout, 'stdout': PIPE, 'stderr': STDOUT})
        new = Popen(*fargs, **fkwargs)
        old.stdout.close()

    return new


def wifi_data():
    networks = []
    out, err = Ppipe(
        akh('sudo iw dev wlp6s0 scan', shell=True),
        akh('egrep "BSS ..:|SSID|RSN|signal"', shell=True)
    ).communicate()
    # TODO: regulate each profile to be exactly four lines long
    data = [
        [line.strip()
         for line in netw.splitlines()]
        for netw in re.split('BSS ..:', out.decode())[1:]]

    for profile_scan in data:
        new_netw = Profile.empty.copy()
        for entry in profile_scan:
            if 'SSID' in entry:
                new_netw['SSID'] = re.split('SSID: *', entry)[1]
            elif 'associated' in entry:
                new_netw['connected'] = True
            elif 'RSN' in entry:
                new_netw['secure'] = True
            elif 'signal' in entry:
                signal = re.search(r'\d\d', entry).group(0)
                new_netw['signal'] = int(signal)
        networks.append(new_netw)

    def sort_key(netw):
        return netw['signal']

    return sorted(networks, key=sort_key)


def current_pf_name():
    import os
    out, err = Popen(
        ['iwgetid', '-r'],
        stdout=PIPE
    ).communicate()
    connected_ssid = out[:-1].decode().replace(' ', '\ ')

    ssid_searcher = re.compile('ESSID=(.*)')
    netctl_dir = '/etc/netctl'
    profiles = filter(
        os.path.isfile,
        (os.path.join(netctl_dir, file) for file in os.listdir(netctl_dir))
    )

    for full_path in profiles:
        out, err = Ppipe(
            akh(['sudo', 'less', full_path]),
            akh(['egrep', 'ESSID='])
        ).communicate()
        profile_ssid = out.decode()
        parsed_ssid = ssid_searcher.findall(profile_ssid)[0]
        if parsed_ssid == connected_ssid:
            return os.path.split(full_path)[1]


def random_data():
    from random import choice, randint, random
    from string import ascii_letters, digits

    def rand_pf():
        return {
            'SSID': ''.join(
                choice(ascii_letters + digits) for _ in range(randint(8, 32))),
            'connected': False,
            'secure': (False, True)[random() < (2 / 3)],
            'signal': randint(25, 99),
        }

    def sort_key(pf):
        return pf['signal']

    res = sorted([rand_pf() for _ in range(randint(3, 30))], key=sort_key)
    choice(res[:3])['connected'] = True
    return res


class Profile(MutableMapping):
    # implement abstract methods

    def __getitem__(self, key):
        return self.__dict.__getitem__(key)

    def __setitem__(self, key, value):
        self.__dict.__setitem__(key, value)

    def __delitem__(self, key):
        self.__dict.__delitem__(key)

    def __iter__(self):
        return self.__dict.__iter__()

    def __len__(self):
        return self.__dict.__len__()

    # implement class

    empty = {
        'SSID': '',
        'connected': False,
        'secure': False,
        'signal': 0,
        'key': '', }

    def __init__(self, *a_dict_args, **a_dict_kwargs):
        self.__dict = self.empty
        self.__dict.update(dict(*a_dict_args, **a_dict_kwargs))
        self.pf_name = '%s-profile' % self['SSID'].split(' ')[0][:8]
        self.pf_path = '/etc/netctl/%s' % self.pf_name

    def profile_str(self):
        description, essid, key = (line.replace(' ', '\ ') for line in (
            'Automatically generated by cheese\'s netctl tool',
            self['SSID'],
            self['key']))

        return '\n'.join(filter(None, [
            'Description=%s' % description,
            'Interface=wlp6s0',
            'Connection=wireless',
            'Security=wpa' if self['secure'] else None,
            'ESSID=%s' % essid,
            'IP=dhcp',
            'Key=%s' % key if self['secure'] else None, ])) + '\n'

    def generate_profile(self):
        out, err = Popen(
            ['sudo', 'tee', self.pf_path],
            stdin=PIPE, stdout=PIPE, stderr=STDOUT
        ).communicate(input=self.profile_str().encode())
        return err.decode() if err is not None else None

    def command(self, cmd):
        out, err = Popen(
            ['sudo', 'netctl', cmd, self.pf_name],
            stdout=PIPE, stderr=STDOUT
        ).communicate()
        return err.decode() if err is not None else None

    @staticmethod
    def man_netctl():
        # TODO: regex output to show commands for self.command()
        out, err = Popen(
            'man -P cat netctl'.split(),
            stdout=PIPE, stderr=STDOUT
        ).communicate()
        return out.decode()


def main():
    # for use with interactive shell
    global data
    from pprint import pprint as print
    data = wifi_data()
    print(data)


if __name__ == '__main__':
    main()
