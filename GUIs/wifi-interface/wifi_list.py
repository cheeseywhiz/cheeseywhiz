import re
import subprocess


def wifi_data():
    def split_keep(self):
        regex = re.compile('BSS ..:')
        matches = regex.findall(self)
        data = regex.split(self)[1:]
        return (
            ''.join(pair)
            for pair in zip(matches, data))

    networks = []
    stdout = subprocess.run(
        'sudo iw dev wlp6s0 scan',
        shell=True, stdout=subprocess.PIPE).stdout
    data = stdout.decode('utf-8')
    data = [
        [chunk.strip()
         for chunk in netw.splitlines()]
        for netw in split_keep(data)]

    for profile_scan in data:
        new_netw = {
            'SSID': '',
            'connected': False,
            'secure': False,
            'signal': 0, }
        for entry in profile_scan:
            if 'SSID' in entry:
                new_netw['SSID'] = re.split(r'SSID: *', entry)[1]
            elif 'associated' in entry:
                new_netw['connected'] = True
            elif 'RSN' in entry:
                new_netw['secure'] = True
            elif 'signal' in entry:
                signal = re.search(r'\d\d', entry).group(0)
                new_netw['signal'] = int(signal)
        networks.append(Profile(new_netw))

    def sort_key(netw):
        return netw['signal']

    return sorted(networks, key=sort_key)


class Profile(dict):
    def __init__(self, inst: dict):
        self.inst = inst
        self.key = ''
        super().__init__(self.inst)
        self.pf_name = f"{self['SSID'].split(' ')[0]}-profile"
        self.pf_path = f'/etc/netctl/{self.pf_name}'

    def generate_profile(self):
        subprocess.run(
            f"sudo echo '{str(self)}' | sudo dd of={self.pf_path}",
            shell=True)

    def command(self, cmd):
        return subprocess.run(
            f'sudo netctl {cmd} {self.pf_name}', shell=True)

    def __str__(self):
        def escape_space(str_):
            return str_.replace(' ', '\ ')
        description, essid, key = map(escape_space, [
            'Automatically generated by cheese\'s netctl tool',
            self['SSID'],
            self.key])
        return '\n'.join(filter(None, [
            f'Description={description}',
            'Interface=wlp6s0',
            'Connection=wireless',
            'Security=wpa' if self['secure'] else None,
            f'ESSID={essid}',
            'IP=dhcp',
            f'Key={key}' if self.key else None, ]))

    def __repr__(self):
        return f'Profile({repr(self.inst)})'

    def key_prompt(self):
        return input('Password: ')

    def key_handle_expception(self, exception):
        print(str(exception))

    def __enter__(self):
        if not self['secure']:
            return self
        while True:
            self.key = self.key_prompt()
            if len(self.key) < 8:
                self.key_handle_expception(ValueError(
                    'Error: password shorter than 8 characters'))
            elif len(self.key) > 63:
                self.key_handle_expception(ValueError(
                    'Error: password longer than 63 characters'))
            else:
                return self

    def __exit__(self, e_type, e_val, e_tb):
        self.key = ''


def main():
    global data
    data = wifi_data()
    print(data)


if __name__ == '__main__':
    main()
