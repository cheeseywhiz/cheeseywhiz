% Spencer Todd
% April 2018, AP Computer Science Principles, Mr. Tull

\documentclass[11pt]{article}

\usepackage{graph}

\begin{document}\fontfamily{lmr}\selectfont
\section{a}\\
This project was written in Python and uses a number of Python third-party libraries, such as Matplotlib, NumPy, and
SymPy.\double

This program implements a level surface visualization for functions of three variables by graphing the function's level
surfaces. The visualization is an analog to level curves for functions of two variables. Functions of one and two variables
are trivial to represent in our three dimensional world, but functions of three dimensions are not. On a level surface graph,
the surfaces represent where the function has the same value. An application of level surfaces would be to visualize how a
variable changes over three dimensions, such as temperature, air pressure, or brightness from a light source.\double
The video demonstrates the visualization of the function $f\paren{x,y,z}=\frac{z}{\sqrt{x^2+y^2}}$, as well as one possible interface
to the program, the command line parameters.\double

\section{b}\\
Before starting this project, I was already familiar with Matplotlib 2D plotting, as well as how I can use NumPy matrices to
plot data. In order to become familiar with the Matplotlib 3D interface, I initially plotted two variable functions by hard
coding transformations of the $x$ and $y$ domain matrices. To make the program interactive, I replaced the hard coded
expressions with evaluated interactive input. Then, I familiarized myself with enough relevant functions of the SymPy library
in order to implement my mathematical algorithm. Using the interactive Python console to tinker with the libraries readily
sped up my learning process. For the program as a whole, I initially implemented the program all in one to two functions,
then I would separate different chunks into more readable, individual functions.\double

All development and library research was independent.\double

\section{c}
\lstinputlisting[firstline=60,lastline=63,firstnumber=60]{graph.py}

The \verb|solve_z_prompt()| function integrates a mathematical algorithm with a logical algorithm in order to collect a string
and manipulate it mathematically. There are two main branches of the algorithm in order to achieve this, the functions
\verb|solve_z()| and \verb|prompt_expression()|.\double

The function \verb|prompt_expression()| gathers a string of text from the user, deciding whether to read the command line artguments,
from an interactive prompt, or from a shell pipe. The algorithm implemented by the function also decides whether the shell pipe
flag should or should not have been supplied. The algorithm does not decide whether the string is a valid expression.\double

The function \verb|solve_z()| implements the following algorithm: the expression $f\paren{x,y,z}$ is put into an
equation, $C=f\paren{x,y,z}$, whereas $C$ is an arbitrary constant; the equation is solved for $z$; then the solutions to the
equation are returned. The library call dictates that a list of expressions that satisfy the solution is returned.\double

Putting these functions together, \verb|solve_z_prompt()| prompts the user for an expression, then returns the list of solutions
of that expression set equal to $C$ and solved for $z$.\double

\section{d}
\lstinputlisting[firstline=83,lastline=93,firstnumber=83]{graph.py}

The function \verb|map_f_xy()| makes it simple to iterate over a 2D table of coordinate pairs (which is a 3D table of numbers).
The function is analogous to a Numpy vector function, like the functions \verb|np.sin()| or \verb|np.sqrt()|, which apply the
same function to each individual number in the matrix, but \verb|map_f_xy()| applies the same function to each coordinate pair
in the input meshgrid. The structure of the meshgrid is that $x$ and $y$ values are stored in separate tables but in the same
index, so working with individual coordinate pairs is difficult. Applying a transposition to the meshgrid will pair each
corresponding $x$ and $y$ and arrange them in a 2D table. Then, it is simple to iterate through each row. On each iteration,
the input function is applied to the coordinate pair, and the answer is stored in the output matrix.\double

This abstraction is required, because the main purpose of the program is to plot 3D functions over a 2D domain.
\end{document}
